name: Création de l'infrastructure

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environnement de déploiement'
        required: true
        default: 'development'
        type: choice
        options:
          - development
          - staging
          - main
          - all

env:
  AWS_REGION: ca-central-1
  ECR_REPOSITORY_APP: projet-c/app
  EKS_CLUSTER_NAME: projet-c-cluster
  TF_VAR_region: ca-central-1
  TF_BACKEND_BUCKET: projet-c-terraform-state
  TF_BACKEND_DYNAMODB: projet-c-terraform-locks

jobs:
  setup-backend-tf:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Decode AWS credentials
        run: |
          echo "${{ secrets.AWS_CREDENTIALS_BASE64 }}" | base64 -d > aws-credentials.json
          echo "AWS_ACCESS_KEY_ID=$(jq -r .aws_access_key_id aws-credentials.json)" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=$(jq -r .aws_secret_access_key aws-credentials.json)" >> $GITHUB_ENV
          rm aws-credentials.json
      
      - name: Configure AWS CLI
        run: |
          aws configure set region ${{ env.AWS_REGION }}
          aws configure set output json
      
      - name: Create S3 bucket if not exists
        run: |
          if ! aws s3api head-bucket --bucket ${{ env.TF_BACKEND_BUCKET }} 2>/dev/null; then
            aws s3api create-bucket \
              --bucket ${{ env.TF_BACKEND_BUCKET }} \
              --region ${{ env.AWS_REGION }} \
              --create-bucket-configuration LocationConstraint=${{ env.AWS_REGION }}
            
            # Activer le versionnement
            aws s3api put-bucket-versioning \
              --bucket ${{ env.TF_BACKEND_BUCKET }} \
              --versioning-configuration Status=Enabled
            
            # Activer le chiffrement
            aws s3api put-bucket-encryption \
              --bucket ${{ env.TF_BACKEND_BUCKET }} \
              --server-side-encryption-configuration '{
                "Rules": [
                  {
                    "ApplyServerSideEncryptionByDefault": {
                      "SSEAlgorithm": "AES256"
                    }
                  }
                ]
              }'
            
            # Bloquer l'accès public
            aws s3api put-public-access-block \
              --bucket ${{ env.TF_BACKEND_BUCKET }} \
              --public-access-block-configuration "BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true"
          else
            echo "S3 bucket ${{ env.TF_BACKEND_BUCKET }} already exists"
          fi
      
      - name: Create DynamoDB table if not exists
        run: |
          if ! aws dynamodb describe-table --table-name ${{ env.TF_BACKEND_DYNAMODB }} 2>/dev/null; then
            aws dynamodb create-table \
              --region ${{ env.AWS_REGION }} \
              --table-name ${{ env.TF_BACKEND_DYNAMODB }} \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST
          else
            echo "DynamoDB table ${{ env.TF_BACKEND_DYNAMODB }} already exists"
          fi
  
  infrastructure:
    needs: setup-backend-tf
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Decode AWS credentials
        run: |
          echo "${{ secrets.AWS_CREDENTIALS_BASE64 }}" | base64 -d > aws-credentials.json
          echo "AWS_ACCESS_KEY_ID=$(jq -r .aws_access_key_id aws-credentials.json)" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=$(jq -r .aws_secret_access_key aws-credentials.json)" >> $GITHUB_ENV
          rm aws-credentials.json
      
      - name: Generate SSH key pair
        run: |
          ssh-keygen -t rsa -b 4096 -f id_rsa -N ""
          echo "TF_VAR_ssh_public_key=$(cat id_rsa.pub)" >> $GITHUB_ENV
          mkdir -p ssh-keys
          cp id_rsa ssh-keys/
          cp id_rsa.pub ssh-keys/
      
      - name: Generate DB password
        run: |
          DB_PASSWORD=$(openssl rand -base64 16)
          echo "TF_VAR_db_password=$DB_PASSWORD" >> $GITHUB_ENV
          echo "$DB_PASSWORD" > ssh-keys/db_password.txt
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.0.0
      
      - name: Set environment
        id: set-env
        run: |
          SELECTED_ENV="${{ github.event.inputs.environment }}"
          
          if [[ "$SELECTED_ENV" == "main" ]]; then
            echo "ENV=production" >> $GITHUB_ENV
            echo "ENVIRONMENTS=production" >> $GITHUB_ENV
          elif [[ "$SELECTED_ENV" == "all" ]]; then
            echo "ENV=all" >> $GITHUB_ENV
            echo "ENVIRONMENTS=development,staging,production" >> $GITHUB_ENV
          else
            echo "ENV=$SELECTED_ENV" >> $GITHUB_ENV
            echo "ENVIRONMENTS=$SELECTED_ENV" >> $GITHUB_ENV
          fi
          
          echo "Environnement(s) sélectionné(s): $SELECTED_ENV"
          echo "Déploiement sur: $(echo $GITHUB_ENV | grep ENVIRONMENTS | cut -d'=' -f2)"
      
      - name: Deploy Infrastructure
        working-directory: ./infra/terraform
        run: |
          IFS=',' read -ra ENVS <<< "${{ env.ENVIRONMENTS }}"
          
          for environment in "${ENVS[@]}"; do
            echo "=== Déploiement pour l'environnement: $environment ==="
            
            # Copier les fichiers Terraform dans un répertoire temporaire pour cet environnement
            mkdir -p "../temp-$environment"
            cp -r * "../temp-$environment/"
            cd "../temp-$environment"
            
            # Remplacer le placeholder env/ par l'environnement réel dans la clé du backend
            sed -i "s|key=\"env/|key=\"$environment/|g" backend.tf
            
            # Terraform Init
            echo "Initialisation Terraform pour $environment..."
            terraform init
            
            # Terraform Validate
            echo "Validation Terraform pour $environment..."
            terraform validate
            
            # Terraform Plan
            echo "Planification Terraform pour $environment..."
            terraform plan -var="environment=$environment" -out="tfplan-$environment"
            
            # Terraform Apply
            echo "Application Terraform pour $environment..."
            terraform apply -auto-approve "tfplan-$environment"
            
            # Sauvegarder les outputs pour cet environnement
            terraform output -json > "../../terraform-outputs-$environment.json"
            
            cd "../../terraform"
            echo "=== Fin du déploiement pour $environment ==="
          done

      - name: Upload Terraform Outputs
        uses: actions/upload-artifact@v4
        with:
          name: terraform-outputs
          path: ./infra/terraform-outputs-*.json
          retention-days: 7
      
      - name: Upload SSH keys and DB password
        uses: actions/upload-artifact@v4
        with:
          name: credentials
          path: ./ssh-keys/
          retention-days: 7
  
  configure-servers:
    needs: infrastructure
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Decode AWS credentials
        run: |
          echo "${{ secrets.AWS_CREDENTIALS_BASE64 }}" | base64 -d > aws-credentials.json
          echo "AWS_ACCESS_KEY_ID=$(jq -r .aws_access_key_id aws-credentials.json)" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=$(jq -r .aws_secret_access_key aws-credentials.json)" >> $GITHUB_ENV
          rm aws-credentials.json
      
      - name: Download Terraform Outputs
        uses: actions/download-artifact@v4
        with:
          name: terraform-outputs
          path: ./infra/ansible
      
      - name: Download SSH keys
        uses: actions/download-artifact@v4
        with:
          name: credentials
          path: ./ssh-keys
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
      
      - name: Install Ansible
        run: |
          python -m pip install --upgrade pip
          pip install ansible boto3
      
      - name: Create Ansible inventory
        working-directory: ./infra/ansible
        run: |
          cat > inventory.ini << EOF
          [github_runner]
          $(jq -r '.github_runner_ip.value' terraform-outputs.json) ansible_user=ec2-user ansible_ssh_private_key_file=~/.ssh/id_rsa
          
          [sonarqube]
          $(jq -r '.sonarqube_ip.value' terraform-outputs.json) ansible_user=ec2-user ansible_ssh_private_key_file=~/.ssh/id_rsa
          
          [monitoring]
          $(jq -r '.monitoring_ip.value' terraform-outputs.json) ansible_user=ec2-user ansible_ssh_private_key_file=~/.ssh/id_rsa
          EOF
          cat inventory.ini

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          cp ./ssh-keys/id_rsa ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          
          # Afficher la clé publique pour vérification
          echo "Clé publique utilisée:"
          cat ./ssh-keys/id_rsa.pub
          
          # Attendre que les instances soient prêtes pour SSH (60 secondes)
          echo "Attente de 60 secondes pour que les instances soient prêtes pour SSH..."
          sleep 60

      - name: Configure SSH on instances
        working-directory: ./infra/ansible
        run: |
          # Extraire les adresses IP
          GITHUB_RUNNER_IP=$(jq -r '.github_runner_ip.value' terraform-outputs.json)
          SONARQUBE_IP=$(jq -r '.sonarqube_ip.value' terraform-outputs.json)
          MONITORING_IP=$(jq -r '.monitoring_ip.value' terraform-outputs.json)
          
          # Récupérer la clé SSH utilisée pour le provisionnement Terraform
          TF_SSH_KEY=$(cat ../terraform/terraform.tfstate | jq -r '.resources[] | select(.type == "aws_key_pair") | .instances[0].attributes.public_key')
          
          # Utiliser cette clé pour la connexion initiale
          echo "$TF_SSH_KEY" > ~/.ssh/id_rsa.pub
          
          # Attendre que les instances soient accessibles
          for IP in $GITHUB_RUNNER_IP $SONARQUBE_IP $MONITORING_IP; do
            echo "Waiting for $IP to be accessible..."
            timeout 300 bash -c "until nc -z $IP 22; do sleep 5; done" || echo "Timeout waiting for $IP"
          done
       
      - name: Generate GitHub Runner token
        id: get-runner-token
        continue-on-error: true
        run: |
          # Utiliser le token PAT avec les permissions nécessaires
          TOKEN="${{ secrets.RUNNER_TOKEN }}"
          if [ -z "$TOKEN" ]; then
            echo "::warning::RUNNER_TOKEN secret is not set. Using a placeholder token."
            echo "placeholder-token" > ./ssh-keys/github_runner_token.txt
          else
            RESPONSE=$(curl -s -X POST \
              -H "Authorization: token $TOKEN" \
              -H "Accept: application/vnd.github.v3+json" \
              https://api.github.com/repos/${{ github.repository }}/actions/runners/registration-token)
            
            RUNNER_TOKEN=$(echo $RESPONSE | jq -r .token)
            if [ "$RUNNER_TOKEN" != "null" ] && [ -n "$RUNNER_TOKEN" ]; then
              echo $RUNNER_TOKEN > ./ssh-keys/github_runner_token.txt
              echo "token=$RUNNER_TOKEN" >> $GITHUB_OUTPUT
            else
              echo "::warning::Failed to get runner token. Using a placeholder token."
              echo "placeholder-token" > ./ssh-keys/github_runner_token.txt
              echo "token=placeholder-token" >> $GITHUB_OUTPUT
            fi
          fi
      
      - name: Upload updated credentials
        uses: actions/upload-artifact@v4
        with:
          name: credentials-updated
          path: ./ssh-keys/
          retention-days: 7
      
      - name: Run Ansible playbook
        working-directory: ./infra/ansible
        continue-on-error: true
        run: |
          export ANSIBLE_HOST_KEY_CHECKING=False
          ansible-playbook -i inventory.ini playbook.yml \
            -e "github_account=${{ github.repository_owner }} github_repo=${{ github.repository }} runner_token=${{ steps.get-runner-token.outputs.token }}" \
            --ssh-common-args='-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=10' \
            -vvv
            
  generate-report:
    needs: configure-servers
    runs-on: ubuntu-latest
    steps:
      - name: Download Terraform Outputs
        uses: actions/download-artifact@v4
        with:
          name: terraform-outputs
      
      - name: Download credentials
        uses: actions/download-artifact@v4
        with:
          name: credentials-updated
          path: ./credentials
      
      - name: Generate deployment report
        run: |
          cat > deployment-report.md << EOF
          # Rapport de déploiement
          
          ## Informations d'infrastructure
          
          - **GitHub Runner IP**: $(jq -r '.github_runner_ip.value' terraform-outputs.json)
          - **SonarQube IP**: $(jq -r '.sonarqube_ip.value' terraform-outputs.json)
          - **Monitoring IP**: $(jq -r '.monitoring_ip.value' terraform-outputs.json)
          - **Base de données**: $(jq -r '.db_endpoint.value' terraform-outputs.json)
          - **Cluster EKS**: $(jq -r '.eks_cluster_name.value' terraform-outputs.json)
          
          ## Accès
          
          Les informations d'accès ont été sauvegardées dans les artifacts de cette exécution:
          
          - Clé SSH privée
          - Mot de passe de la base de données
          - Token GitHub Runner
          
          ## Environnement déployé
          
          $(if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then echo "${{ github.event.inputs.environment }}"; elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then echo "production"; elif [[ "${{ github.ref }}" == "refs/heads/staging" ]]; then echo "staging"; elif [[ "${{ github.ref }}" == "refs/heads/development" ]]; then echo "development"; else echo "development"; fi)
          
          ## Date de déploiement
          
          $(date)
          EOF
      
      - name: Upload deployment report
        uses: actions/upload-artifact@v4
        with:
          name: deployment-report
          path: ./deployment-report.md
          retention-days: 30