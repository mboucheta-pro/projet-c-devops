name: Création de l'infrastructure

on:
  push:
    branches: [ main, development, staging ]
    paths:
      - 'infra/**'
  pull_request:
    branches: [ main, development, staging ]
    paths:
      - 'infra/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environnement à déployer'
        required: true
        default: 'development'
        type: choice
        options:
          - development
          - staging
          - production
      confirm_production:
        description: 'Tapez "CONFIRMER" pour déployer en production'
        required: false
        type: string

env:
  AWS_REGION: ca-central-1
  ECR_REPOSITORY_FRONTEND: projet-c/frontend
  ECR_REPOSITORY_BACKEND: projet-c/backend
  EKS_CLUSTER_NAME: projet-c-cluster
  TF_VAR_region: ca-central-1
  TF_BACKEND_BUCKET: projet-c-terraform-state
  TF_BACKEND_DYNAMODB: projet-c-terraform-locks

jobs:
  setup-backend-tf:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Decode AWS credentials
        run: |
          echo "${{ secrets.AWS_CREDENTIALS_BASE64 }}" | base64 -d > aws-credentials.json
          echo "AWS_ACCESS_KEY_ID=$(jq -r .aws_access_key_id aws-credentials.json)" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=$(jq -r .aws_secret_access_key aws-credentials.json)" >> $GITHUB_ENV
          rm aws-credentials.json
      
      - name: Configure AWS CLI
        run: |
          aws configure set region ${{ env.AWS_REGION }}
          aws configure set output json
      
      - name: Create S3 bucket if not exists
        run: |
          if ! aws s3api head-bucket --bucket ${{ env.TF_BACKEND_BUCKET }} 2>/dev/null; then
            aws s3api create-bucket \
              --bucket ${{ env.TF_BACKEND_BUCKET }} \
              --region ${{ env.AWS_REGION }} \
              --create-bucket-configuration LocationConstraint=${{ env.AWS_REGION }}
            
            # Activer le versionnement
            aws s3api put-bucket-versioning \
              --bucket ${{ env.TF_BACKEND_BUCKET }} \
              --versioning-configuration Status=Enabled
            
            # Activer le chiffrement
            aws s3api put-bucket-encryption \
              --bucket ${{ env.TF_BACKEND_BUCKET }} \
              --server-side-encryption-configuration '{
                "Rules": [
                  {
                    "ApplyServerSideEncryptionByDefault": {
                      "SSEAlgorithm": "AES256"
                    }
                  }
                ]
              }'
            
            # Bloquer l'accès public
            aws s3api put-public-access-block \
              --bucket ${{ env.TF_BACKEND_BUCKET }} \
              --public-access-block-configuration "BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true"
          else
            echo "S3 bucket ${{ env.TF_BACKEND_BUCKET }} already exists"
          fi
      
      - name: Create DynamoDB table if not exists
        run: |
          if ! aws dynamodb describe-table --table-name ${{ env.TF_BACKEND_DYNAMODB }} 2>/dev/null; then
            aws dynamodb create-table \
              --region ${{ env.AWS_REGION }} \
              --table-name ${{ env.TF_BACKEND_DYNAMODB }} \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST
          else
            echo "DynamoDB table ${{ env.TF_BACKEND_DYNAMODB }} already exists"
          fi
  
  infrastructure:
    needs: setup-backend-tf
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Decode AWS credentials
        run: |
          echo "${{ secrets.AWS_CREDENTIALS_BASE64 }}" | base64 -d > aws-credentials.json
          echo "AWS_ACCESS_KEY_ID=$(jq -r .aws_access_key_id aws-credentials.json)" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=$(jq -r .aws_secret_access_key aws-credentials.json)" >> $GITHUB_ENV
          rm aws-credentials.json
      
      - name: Generate SSH key pair
        run: |
          ssh-keygen -t rsa -b 4096 -f id_rsa -N ""
          echo "TF_VAR_ssh_public_key=$(cat id_rsa.pub)" >> $GITHUB_ENV
          mkdir -p ssh-keys
          cp id_rsa ssh-keys/
          cp id_rsa.pub ssh-keys/
      
      - name: Generate DB password
        run: |
          DB_PASSWORD=$(openssl rand -base64 16)
          echo "TF_VAR_db_password=$DB_PASSWORD" >> $GITHUB_ENV
          echo "$DB_PASSWORD" > ssh-keys/db_password.txt
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.0.0
      
      - name: Set environment
        id: set-env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "ENV=${{ github.event.inputs.environment }}" >> $GITHUB_ENV
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "ENV=production" >> $GITHUB_ENV
          elif [[ "${{ github.ref }}" == "refs/heads/staging" ]]; then
            echo "ENV=staging" >> $GITHUB_ENV
          elif [[ "${{ github.ref }}" == "refs/heads/development" ]]; then
            echo "ENV=development" >> $GITHUB_ENV
          else
            echo "ENV=development" >> $GITHUB_ENV
          fi
      
      - name: Terraform Init
        working-directory: ./infra/terraform
        run: |
          # Remplacer le placeholder env/ par l'environnement réel dans la clé du backend
          sed -i "s|key=\"env/|key=\"${{ env.ENV }}/|g" backend.tf
          terraform init
      
      - name: Terraform Validate
        working-directory: ./infra/terraform
        run: terraform validate
      
      - name: Terraform Plan
        working-directory: ./infra/terraform
        run: terraform plan -var="environment=${{ env.ENV }}" -out=tfplan
      
      - name: Terraform Apply
        working-directory: ./infra/terraform
        run: terraform apply -auto-approve tfplan

      - name: Save Terraform Outputs
        working-directory: ./infra/terraform
        run: |
          # Extraire tous les outputs Terraform au format JSON dans un fichier
          terraform output -json | grep -v "^::" | grep -v "^\[command\]" > terraform-outputs.json

      - name: Upload Terraform Outputs
        uses: actions/upload-artifact@v4
        with:
          name: terraform-outputs
          path: ./infra/terraform/terraform-outputs.json
          retention-days: 7
      
      - name: Upload SSH keys and DB password
        uses: actions/upload-artifact@v4
        with:
          name: credentials
          path: ./ssh-keys/
          retention-days: 7
  
  configure-servers:
    needs: infrastructure
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Decode AWS credentials
        run: |
          echo "${{ secrets.AWS_CREDENTIALS_BASE64 }}" | base64 -d > aws-credentials.json
          echo "AWS_ACCESS_KEY_ID=$(jq -r .aws_access_key_id aws-credentials.json)" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=$(jq -r .aws_secret_access_key aws-credentials.json)" >> $GITHUB_ENV
          rm aws-credentials.json
      
      - name: Download Terraform Outputs
        uses: actions/download-artifact@v4
        with:
          name: terraform-outputs
          path: ./infra/ansible
      
      - name: Download SSH keys
        uses: actions/download-artifact@v4
        with:
          name: credentials
          path: ./ssh-keys
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
      
      - name: Install Ansible
        run: |
          python -m pip install --upgrade pip
          pip install ansible boto3
      
      - name: Create Ansible inventory
        working-directory: ./infra/ansible
        run: |
          cat > inventory.ini << EOF
          [github_runner]
          $(jq -r '.github_runner_ip.value' terraform-outputs.json) ansible_user=ec2-user ansible_ssh_private_key_file=~/.ssh/id_rsa
          
          [sonarqube]
          $(jq -r '.sonarqube_ip.value' terraform-outputs.json) ansible_user=ec2-user ansible_ssh_private_key_file=~/.ssh/id_rsa
          
          [monitoring]
          $(jq -r '.monitoring_ip.value' terraform-outputs.json) ansible_user=ec2-user ansible_ssh_private_key_file=~/.ssh/id_rsa
          EOF
          cat inventory.ini

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          cp ./ssh-keys/id_rsa ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          
          # Afficher la clé publique pour vérification
          echo "Clé publique utilisée:"
          cat ./ssh-keys/id_rsa.pub
          
          # Attendre que les instances soient prêtes pour SSH (60 secondes)
          echo "Attente de 60 secondes pour que les instances soient prêtes pour SSH..."
          sleep 60

      - name: Configure SSH on instances
        working-directory: ./infra/ansible
        run: |
          # Extraire les adresses IP
          GITHUB_RUNNER_IP=$(jq -r '.github_runner_ip.value' terraform-outputs.json)
          SONARQUBE_IP=$(jq -r '.sonarqube_ip.value' terraform-outputs.json)
          MONITORING_IP=$(jq -r '.monitoring_ip.value' terraform-outputs.json)
          
          # Créer un script pour configurer SSH
          cat > configure_ssh.sh << 'EOF'
          #!/bin/bash
          sudo sed -i 's/^#\?PasswordAuthentication .*/PasswordAuthentication no/' /etc/ssh/sshd_config
          sudo sed -i 's/^#\?PubkeyAuthentication .*/PubkeyAuthentication yes/' /etc/ssh/sshd_config
          sudo mkdir -p ~/.ssh
          echo "$1" > ~/.ssh/authorized_keys
          sudo chmod 700 ~/.ssh
          sudo chmod 600 ~/.ssh/authorized_keys
          sudo chown -R ec2-user:ec2-user ~/.ssh
          sudo systemctl restart sshd
          EOF
          
          chmod +x configure_ssh.sh
          
          # Exécuter le script sur chaque instance
          for IP in $GITHUB_RUNNER_IP $SONARQUBE_IP $MONITORING_IP; do
            echo "Configuring SSH on $IP..."
            ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i ~/.ssh/id_rsa ec2-user@$IP 'bash -s' < configure_ssh.sh "$(cat ~/.ssh/id_rsa.pub)" || echo "Failed to configure $IP"
          done
       
      - name: Generate GitHub Runner token
        id: get-runner-token
        continue-on-error: true
        run: |
          # Utiliser le token PAT avec les permissions nécessaires
          TOKEN="${{ secrets.RUNNER_TOKEN }}"
          if [ -z "$TOKEN" ]; then
            echo "::warning::RUNNER_TOKEN secret is not set. Using a placeholder token."
            echo "placeholder-token" > ./ssh-keys/github_runner_token.txt
          else
            RESPONSE=$(curl -s -X POST \
              -H "Authorization: token $TOKEN" \
              -H "Accept: application/vnd.github.v3+json" \
              https://api.github.com/repos/${{ github.repository }}/actions/runners/registration-token)
            
            RUNNER_TOKEN=$(echo $RESPONSE | jq -r .token)
            if [ "$RUNNER_TOKEN" != "null" ] && [ -n "$RUNNER_TOKEN" ]; then
              echo $RUNNER_TOKEN > ./ssh-keys/github_runner_token.txt
              echo "token=$RUNNER_TOKEN" >> $GITHUB_OUTPUT
            else
              echo "::warning::Failed to get runner token. Using a placeholder token."
              echo "placeholder-token" > ./ssh-keys/github_runner_token.txt
              echo "token=placeholder-token" >> $GITHUB_OUTPUT
            fi
          fi
      
      - name: Upload updated credentials
        uses: actions/upload-artifact@v4
        with:
          name: credentials-updated
          path: ./ssh-keys/
          retention-days: 7
      
      - name: Run Ansible playbook
        working-directory: ./infra/ansible
        continue-on-error: true
        run: |
          export ANSIBLE_HOST_KEY_CHECKING=False
          ansible-playbook -i inventory.ini playbook.yml \
            -e "github_account=${{ github.repository_owner }} github_repo=${{ github.repository }} runner_token=${{ steps.get-runner-token.outputs.token }}" \
            --ssh-common-args='-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=10' \
            -vvv
            
  generate-report:
    needs: configure-servers
    runs-on: ubuntu-latest
    steps:
      - name: Download Terraform Outputs
        uses: actions/download-artifact@v4
        with:
          name: terraform-outputs
      
      - name: Download credentials
        uses: actions/download-artifact@v4
        with:
          name: credentials-updated
          path: ./credentials
      
      - name: Generate deployment report
        run: |
          cat > deployment-report.md << EOF
          # Rapport de déploiement
          
          ## Informations d'infrastructure
          
          - **GitHub Runner IP**: $(jq -r '.github_runner_ip.value' terraform-outputs.json)
          - **SonarQube IP**: $(jq -r '.sonarqube_ip.value' terraform-outputs.json)
          - **Monitoring IP**: $(jq -r '.monitoring_ip.value' terraform-outputs.json)
          - **Base de données**: $(jq -r '.db_endpoint.value' terraform-outputs.json)
          - **Cluster EKS**: $(jq -r '.eks_cluster_name.value' terraform-outputs.json)
          
          ## Accès
          
          Les informations d'accès ont été sauvegardées dans les artifacts de cette exécution:
          
          - Clé SSH privée
          - Mot de passe de la base de données
          - Token GitHub Runner
          
          ## Environnement déployé
          
          $(if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then echo "${{ github.event.inputs.environment }}"; elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then echo "production"; elif [[ "${{ github.ref }}" == "refs/heads/staging" ]]; then echo "staging"; elif [[ "${{ github.ref }}" == "refs/heads/development" ]]; then echo "development"; else echo "development"; fi)
          
          ## Date de déploiement
          
          $(date)
          EOF
      
      - name: Upload deployment report
        uses: actions/upload-artifact@v4
        with:
          name: deployment-report
          path: ./deployment-report.md
          retention-days: 30