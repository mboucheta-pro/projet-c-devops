name: Gestion de l'infrastructure

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Action à effectuer'
        required: true
        default: 'deploy'
        type: choice
        options:
          - deploy
          - destroy
      confirm_apply:
        description: 'Confirmer apply (après avoir vérifié le plan)'
        required: true
        default: 'no'
        type: choice
        options:
          - 'no'
          - 'yes'
      instances_state:
        description: 'État des instances (running = actives, stopped = arrêtées pour économiser)'
        required: true
        default: 'running'
        type: choice
        options:
          - 'running'
          - 'stopped'

env:
  AWS_REGION: ca-central-1
  ECR_REPOSITORY_APP: projet-c/app
  EKS_CLUSTER_NAME: projet-c-cluster
  TF_VAR_region: ca-central-1
  TF_BACKEND_BUCKET: projet-c-terraform-state
  TF_BACKEND_DYNAMODB: projet-c-terraform-locks

jobs:
  setup-backend-tf:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Decode AWS credentials
        run: |
          echo "${{ secrets.AWS_CREDENTIALS_BASE64 }}" | base64 -d > aws-credentials.json
          echo "AWS_ACCESS_KEY_ID=$(jq -r .aws_access_key_id aws-credentials.json)" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=$(jq -r .aws_secret_access_key aws-credentials.json)" >> $GITHUB_ENV
          rm aws-credentials.json
      
      - name: Configure AWS CLI
        run: |
          aws configure set region ${{ env.AWS_REGION }}
          aws configure set output json
      
      - name: Create S3 bucket if not exists
        run: |
          if ! aws s3api head-bucket --bucket ${{ env.TF_BACKEND_BUCKET }} 2>/dev/null; then
            aws s3api create-bucket \
              --bucket ${{ env.TF_BACKEND_BUCKET }} \
              --region ${{ env.AWS_REGION }} \
              --create-bucket-configuration LocationConstraint=${{ env.AWS_REGION }}
            
            aws s3api put-bucket-versioning \
              --bucket ${{ env.TF_BACKEND_BUCKET }} \
              --versioning-configuration Status=Enabled
            
            aws s3api put-bucket-encryption \
              --bucket ${{ env.TF_BACKEND_BUCKET }} \
              --server-side-encryption-configuration '{
                "Rules": [
                  {
                    "ApplyServerSideEncryptionByDefault": {
                      "SSEAlgorithm": "AES256"
                    }
                  }
                ]
              }'
            
            aws s3api put-public-access-block \
              --bucket ${{ env.TF_BACKEND_BUCKET }} \
              --public-access-block-configuration "BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true"
          fi
      
      - name: Create DynamoDB table if not exists
        run: |
          if ! aws dynamodb describe-table --table-name ${{ env.TF_BACKEND_DYNAMODB }} 2>/dev/null; then
            aws dynamodb create-table \
              --region ${{ env.AWS_REGION }} \
              --table-name ${{ env.TF_BACKEND_DYNAMODB }} \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST
          fi
  
  terraform-plan:
    needs: setup-backend-tf
    runs-on: ubuntu-latest
    if: github.event.inputs.confirm_apply == 'no'
    steps:
      - uses: actions/checkout@v4
      
      - name: Decode AWS credentials
        run: |
          echo "${{ secrets.AWS_CREDENTIALS_BASE64 }}" | base64 -d > aws-credentials.json
          echo "AWS_ACCESS_KEY_ID=$(jq -r .aws_access_key_id aws-credentials.json)" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=$(jq -r .aws_secret_access_key aws-credentials.json)" >> $GITHUB_ENV
          rm aws-credentials.json
      
      - name: Generate SSH key pair
        run: |
          ssh-keygen -t rsa -b 4096 -f $GITHUB_WORKSPACE/id_rsa -N ""
          echo "TF_VAR_ssh_public_key=$(cat $GITHUB_WORKSPACE/id_rsa.pub)" >> $GITHUB_ENV
          if [[ "${{ github.event.inputs.action }}" == "deploy" ]]; then
            mkdir -p $GITHUB_WORKSPACE/ssh-keys
            cp $GITHUB_WORKSPACE/id_rsa $GITHUB_WORKSPACE/ssh-keys/
            cp $GITHUB_WORKSPACE/id_rsa.pub $GITHUB_WORKSPACE/ssh-keys/
          fi
      
      - name: Generate DB password
        run: |
          DB_PASSWORD=$(openssl rand -hex 16 | tr -d '/@" ')
          echo "TF_VAR_db_password=$DB_PASSWORD" >> $GITHUB_ENV
          if [[ "${{ github.event.inputs.action }}" == "deploy" ]]; then
            mkdir -p $GITHUB_WORKSPACE/ssh-keys
            echo "$DB_PASSWORD" > $GITHUB_WORKSPACE/ssh-keys/db_password.txt
          fi
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.0.0
      
      - name: Terraform Plan
        run: |
          cd $GITHUB_WORKSPACE/infra/terraform
          terraform init
          
          INSTANCES_RUNNING=$([[ "${{ github.event.inputs.instances_state }}" == "running" ]] && echo "true" || echo "false")
          
          if [[ "${{ github.event.inputs.action }}" == "deploy" ]]; then
            terraform validate
            terraform plan -var="db_password=$TF_VAR_db_password" -var="ssh_public_key=$TF_VAR_ssh_public_key" -var="instances_running=$INSTANCES_RUNNING" -out="tfplan"
            terraform show -no-color "tfplan" > "tfplan.txt"
          else
            sed -i 's/prevent_destroy = true/prevent_destroy = false/g' *.tf
            terraform plan -destroy -var="db_password=$TF_VAR_db_password" -var="ssh_public_key=$TF_VAR_ssh_public_key" -var="instances_running=$INSTANCES_RUNNING" -out="tfplan"
            terraform show -no-color "tfplan" > "tfplan.txt"
          fi

      - name: Upload Terraform Plan to S3
        run: |
          cd $GITHUB_WORKSPACE/infra/terraform
          aws s3 cp tfplan s3://${{ env.TF_BACKEND_BUCKET }}/plans/tfplan
          aws s3 cp tfplan.txt s3://${{ env.TF_BACKEND_BUCKET }}/plans/tfplan.txt
      
      - name: Upload Terraform Plan (local artifact)
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan
          path: |
            ${{ github.workspace }}/infra/terraform/tfplan
            ${{ github.workspace }}/infra/terraform/tfplan.txt
          retention-days: 7
      
      - name: Upload SSH keys and DB password
        if: github.event.inputs.action == 'deploy'
        uses: actions/upload-artifact@v4
        with:
          name: credentials
          path: ${{ github.workspace }}/ssh-keys/
          retention-days: 7

  terraform-apply:
    needs: setup-backend-tf
    runs-on: ubuntu-latest
    if: github.event.inputs.confirm_apply == 'yes'
    steps:
      - uses: actions/checkout@v4
      
      - name: Decode AWS credentials
        run: |
          echo "${{ secrets.AWS_CREDENTIALS_BASE64 }}" | base64 -d > aws-credentials.json
          echo "AWS_ACCESS_KEY_ID=$(jq -r .aws_access_key_id aws-credentials.json)" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=$(jq -r .aws_secret_access_key aws-credentials.json)" >> $GITHUB_ENV
          rm aws-credentials.json
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.0.0
      
      - name: Download Terraform Plan from S3
        run: |
          cd $GITHUB_WORKSPACE/infra/terraform
          aws s3 cp s3://${{ env.TF_BACKEND_BUCKET }}/plans/tfplan tfplan
          aws s3 cp s3://${{ env.TF_BACKEND_BUCKET }}/plans/tfplan.txt tfplan.txt
      
      - name: Execute Terraform Apply/Destroy
        run: |
          cd $GITHUB_WORKSPACE/infra/terraform
          terraform init
          terraform apply -auto-approve tfplan
          
          if [[ "${{ github.event.inputs.action }}" == "deploy" ]]; then
            terraform output -json > "$GITHUB_WORKSPACE/terraform-outputs.json"
          fi
      
      - name: Upload Terraform Outputs
        if: github.event.inputs.action == 'deploy'
        uses: actions/upload-artifact@v4
        with:
          name: terraform-outputs
          path: ${{ github.workspace }}/terraform-outputs.json
          retention-days: 7

  configure-instances:
    needs: terraform-apply
    runs-on: ubuntu-latest
    if: github.event.inputs.action == 'deploy' && github.event.inputs.instances_state == 'running'
    steps:
      - uses: actions/checkout@v4
      
      - name: Download Terraform Outputs
        uses: actions/download-artifact@v4
        with:
          name: terraform-outputs
          path: ${{ github.workspace }}
      
      - name: Download SSH keys
        uses: actions/download-artifact@v4
        with:
          name: credentials
          path: ${{ github.workspace }}/ssh-keys
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
      
      - name: Install Ansible
        run: pip install ansible
      
      - name: Create Ansible inventory
        run: |
          cd $GITHUB_WORKSPACE/infra/ansible
          cat > inventory.ini << EOF
          [github-runner]
          $(jq -r '."github-runner_ip".value' $GITHUB_WORKSPACE/terraform-outputs.json) ansible_user=ec2-user ansible_ssh_private_key_file=~/.ssh/id_rsa
          
          [sonarqube]
          $(jq -r '.sonarqube_ip.value' $GITHUB_WORKSPACE/terraform-outputs.json) ansible_user=ec2-user ansible_ssh_private_key_file=~/.ssh/id_rsa
          
          [monitoring]
          $(jq -r '.monitoring_ip.value' $GITHUB_WORKSPACE/terraform-outputs.json) ansible_user=ec2-user ansible_ssh_private_key_file=~/.ssh/id_rsa
          EOF
      
      - name: Generate GitHub Runner token
        id: runner-token
        run: |
          RESPONSE=$(curl -s -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            https://api.github.com/repos/${{ github.repository }}/actions/runners/registration-token)
          
          RUNNER_TOKEN=$(echo $RESPONSE | jq -r .token)
          echo "token=$RUNNER_TOKEN" >> $GITHUB_OUTPUT
      
      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          cp $GITHUB_WORKSPACE/ssh-keys/id_rsa ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          
          echo "Attente de 60 secondes pour que les instances soient prêtes..."
          sleep 60
      
      - name: Run Ansible playbook
        run: |
          cd $GITHUB_WORKSPACE/infra/ansible
          export ANSIBLE_HOST_KEY_CHECKING=False
          ansible-playbook -i inventory.ini playbook.yml \
            -e "github_repo=${{ github.repository }}" \
            -e "runner_token=${{ steps.runner-token.outputs.token }}" \
            --ssh-common-args='-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null'