name: Gestion de l'infrastructure

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Action à effectuer'
        required: true
        default: 'deploy'
        type: choice
        options:
          - deploy
          - destroy
      environment:
        description: 'Environnement cible'
        required: true
        default: 'development'
        type: choice
        options:
          - development
          - staging
          - main
          - all

env:
  AWS_REGION: ca-central-1
  ECR_REPOSITORY_APP: projet-c/app
  EKS_CLUSTER_NAME: projet-c-cluster
  TF_VAR_region: ca-central-1
  TF_BACKEND_BUCKET: projet-c-terraform-state
  TF_BACKEND_DYNAMODB: projet-c-terraform-locks

jobs:
  setup-backend-tf:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Decode AWS credentials
        run: |
          echo "${{ secrets.AWS_CREDENTIALS_BASE64 }}" | base64 -d > aws-credentials.json
          echo "AWS_ACCESS_KEY_ID=$(jq -r .aws_access_key_id aws-credentials.json)" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=$(jq -r .aws_secret_access_key aws-credentials.json)" >> $GITHUB_ENV
          rm aws-credentials.json
      
      - name: Configure AWS CLI
        run: |
          aws configure set region ${{ env.AWS_REGION }}
          aws configure set output json
      
      - name: Create S3 bucket if not exists
        run: |
          if ! aws s3api head-bucket --bucket ${{ env.TF_BACKEND_BUCKET }} 2>/dev/null; then
            aws s3api create-bucket \
              --bucket ${{ env.TF_BACKEND_BUCKET }} \
              --region ${{ env.AWS_REGION }} \
              --create-bucket-configuration LocationConstraint=${{ env.AWS_REGION }}
            
            # Activer le versionnement
            aws s3api put-bucket-versioning \
              --bucket ${{ env.TF_BACKEND_BUCKET }} \
              --versioning-configuration Status=Enabled
            
            # Activer le chiffrement
            aws s3api put-bucket-encryption \
              --bucket ${{ env.TF_BACKEND_BUCKET }} \
              --server-side-encryption-configuration '{
                "Rules": [
                  {
                    "ApplyServerSideEncryptionByDefault": {
                      "SSEAlgorithm": "AES256"
                    }
                  }
                ]
              }'
            
            # Bloquer l'accès public
            aws s3api put-public-access-block \
              --bucket ${{ env.TF_BACKEND_BUCKET }} \
              --public-access-block-configuration "BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true"
          else
            echo "S3 bucket ${{ env.TF_BACKEND_BUCKET }} already exists"
          fi
      
      - name: Create DynamoDB table if not exists
        run: |
          if ! aws dynamodb describe-table --table-name ${{ env.TF_BACKEND_DYNAMODB }} 2>/dev/null; then
            aws dynamodb create-table \
              --region ${{ env.AWS_REGION }} \
              --table-name ${{ env.TF_BACKEND_DYNAMODB }} \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST
          else
            echo "DynamoDB table ${{ env.TF_BACKEND_DYNAMODB }} already exists"
          fi
  
  terraform-plan:
    needs: setup-backend-tf
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Decode AWS credentials
        run: |
          echo "${{ secrets.AWS_CREDENTIALS_BASE64 }}" | base64 -d > aws-credentials.json
          echo "AWS_ACCESS_KEY_ID=$(jq -r .aws_access_key_id aws-credentials.json)" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=$(jq -r .aws_secret_access_key aws-credentials.json)" >> $GITHUB_ENV
          rm aws-credentials.json
      
      - name: Generate SSH key pair
        if: github.event.inputs.action == 'deploy'
        run: |
          ssh-keygen -t rsa -b 4096 -f $GITHUB_WORKSPACE/id_rsa -N ""
          echo "TF_VAR_ssh_public_key=$(cat $GITHUB_WORKSPACE/id_rsa.pub)" >> $GITHUB_ENV
          mkdir -p $GITHUB_WORKSPACE/ssh-keys
          cp $GITHUB_WORKSPACE/id_rsa $GITHUB_WORKSPACE/ssh-keys/
          cp $GITHUB_WORKSPACE/id_rsa.pub $GITHUB_WORKSPACE/ssh-keys/
      
      - name: Generate DB password
        if: github.event.inputs.action == 'deploy'
        run: |
          DB_PASSWORD=$(openssl rand -base64 16)
          echo "TF_VAR_db_password=$DB_PASSWORD" >> $GITHUB_ENV
          echo "$DB_PASSWORD" > $GITHUB_WORKSPACE/ssh-keys/db_password.txt
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.0.0
      
      - name: Set environment
        id: set-env
        run: |
          SELECTED_ENV="${{ github.event.inputs.environment }}"
          
          if [[ "$SELECTED_ENV" == "main" ]]; then
            echo "ENV=production" >> $GITHUB_ENV
            echo "ENVIRONMENTS=production" >> $GITHUB_ENV
          elif [[ "$SELECTED_ENV" == "all" ]]; then
            echo "ENV=all" >> $GITHUB_ENV
            echo "ENVIRONMENTS=development,staging,production" >> $GITHUB_ENV
          else
            echo "ENV=$SELECTED_ENV" >> $GITHUB_ENV
            echo "ENVIRONMENTS=$SELECTED_ENV" >> $GITHUB_ENV
          fi
          
          echo "Environnement(s) sélectionné(s): $SELECTED_ENV"
          echo "Déploiement sur: $(echo $GITHUB_ENV | grep ENVIRONMENTS | cut -d'=' -f2)"
      
      - name: Terraform Plan
        run: |
          ACTION="${{ github.event.inputs.action }}"
          IFS=',' read -ra ENVS <<< "${{ env.ENVIRONMENTS }}"
          
          for environment in "${ENVS[@]}"; do
            echo "=== Plan pour l'environnement: $environment ==="
            
            mkdir -p "$GITHUB_WORKSPACE/temp-$environment"
            cp -r $GITHUB_WORKSPACE/infra/terraform/* "$GITHUB_WORKSPACE/temp-$environment/"
            cd "$GITHUB_WORKSPACE/temp-$environment"
            
            sed -i "s|key=\"env/|key=\"$environment/|g" backend.tf
            
            terraform init
            
            if [[ "$ACTION" == "deploy" ]]; then
              terraform validate
              terraform plan -var="environment=$environment" -out="tfplan-$environment"
            else
              terraform plan -destroy -var="environment=$environment" -out="tfplan-$environment"
            fi
            
            cp "tfplan-$environment" "$GITHUB_WORKSPACE/tfplan-$environment"
          done

      - name: Upload Terraform Plans
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plans
          path: ${{ github.workspace }}/tfplan-*
          retention-days: 7
      
      - name: Upload SSH keys and DB password
        if: github.event.inputs.action == 'deploy'
        uses: actions/upload-artifact@v4
        with:
          name: credentials
          path: ${{ github.workspace }}/ssh-keys/
          retention-days: 7

  terraform-apply:
    needs: terraform-plan
    runs-on: ubuntu-latest
    environment: manual-approval
    steps:
      - uses: actions/checkout@v4
      
      - name: Decode AWS credentials
        run: |
          echo "${{ secrets.AWS_CREDENTIALS_BASE64 }}" | base64 -d > aws-credentials.json
          echo "AWS_ACCESS_KEY_ID=$(jq -r .aws_access_key_id aws-credentials.json)" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=$(jq -r .aws_secret_access_key aws-credentials.json)" >> $GITHUB_ENV
          rm aws-credentials.json
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.0.0
      
      - name: Set environment
        run: |
          SELECTED_ENV="${{ github.event.inputs.environment }}"
          if [[ "$SELECTED_ENV" == "main" ]]; then
            echo "ENVIRONMENTS=production" >> $GITHUB_ENV
          elif [[ "$SELECTED_ENV" == "all" ]]; then
            echo "ENVIRONMENTS=development,staging,production" >> $GITHUB_ENV
          else
            echo "ENVIRONMENTS=$SELECTED_ENV" >> $GITHUB_ENV
          fi
      
      - name: Download Terraform Plans
        uses: actions/download-artifact@v4
        with:
          name: terraform-plans
          path: ${{ github.workspace }}
      
      - name: Execute Terraform Apply/Destroy
        run: |
          ACTION="${{ github.event.inputs.action }}"
          IFS=',' read -ra ENVS <<< "${{ env.ENVIRONMENTS }}"
          
          for environment in "${ENVS[@]}"; do
            mkdir -p "$GITHUB_WORKSPACE/temp-apply-$environment"
            cp -r $GITHUB_WORKSPACE/infra/terraform/* "$GITHUB_WORKSPACE/temp-apply-$environment/"
            cp "$GITHUB_WORKSPACE/tfplan-$environment" "$GITHUB_WORKSPACE/temp-apply-$environment/"
            cd "$GITHUB_WORKSPACE/temp-apply-$environment"
            
            sed -i "s|key=\"env/|key=\"$environment/|g" backend.tf
            terraform init
            
            if [[ "$ACTION" == "deploy" ]]; then
              echo "=== Application pour $environment ==="
              terraform apply -auto-approve "tfplan-$environment"
              terraform output -json > "$GITHUB_WORKSPACE/terraform-outputs-$environment.json"
            else
              echo "=== Destruction pour $environment ==="
              terraform apply -auto-approve "tfplan-$environment"
            fi
          donection pour $environment ==="
              terraform apply -auto-approve "tfplan-$environment"
            fi
            
            cd "../../terraform"
          done
      
      - name: Upload Terraform Outputs
        if: github.event.inputs.action == 'deploy'
        uses: actions/upload-artifact@v4
        with:
          name: terraform-outputs
          path: ${{ github.workspace }}/terraform-outputs-*.json
          retention-days: 7
  
  configure-servers:
    needs: terraform-apply
    if: github.event.inputs.action == 'deploy'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Decode AWS credentials
        run: |
          echo "${{ secrets.AWS_CREDENTIALS_BASE64 }}" | base64 -d > aws-credentials.json
          echo "AWS_ACCESS_KEY_ID=$(jq -r .aws_access_key_id aws-credentials.json)" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=$(jq -r .aws_secret_access_key aws-credentials.json)" >> $GITHUB_ENV
          rm aws-credentials.json
      
      - name: Download Terraform Outputs
        uses: actions/download-artifact@v4
        with:
          name: terraform-outputs
          path: ${{ github.workspace }}/infra/ansible
      
      - name: Download SSH keys
        uses: actions/download-artifact@v4
        with:
          name: credentials
          path: ${{ github.workspace }}/ssh-keys
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
      
      - name: Install Ansible
        run: |
          python -m pip install --upgrade pip
          pip install ansible boto3
      
      - name: Create Ansible inventory
        run: |
          cd $GITHUB_WORKSPACE/infra/ansible
          cat > inventory.ini << EOF
          [github_runner]
          $(jq -r '.github_runner_ip.value' terraform-outputs.json) ansible_user=ec2-user ansible_ssh_private_key_file=~/.ssh/id_rsa
          
          [sonarqube]
          $(jq -r '.sonarqube_ip.value' terraform-outputs.json) ansible_user=ec2-user ansible_ssh_private_key_file=~/.ssh/id_rsa
          
          [monitoring]
          $(jq -r '.monitoring_ip.value' terraform-outputs.json) ansible_user=ec2-user ansible_ssh_private_key_file=~/.ssh/id_rsa
          EOF
          cat inventory.ini

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          cp $GITHUB_WORKSPACE/ssh-keys/id_rsa ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          
          # Afficher la clé publique pour vérification
          echo "Clé publique utilisée:"
          cat $GITHUB_WORKSPACE/ssh-keys/id_rsa.pub
          
          # Attendre que les instances soient prêtes pour SSH (60 secondes)
          echo "Attente de 60 secondes pour que les instances soient prêtes pour SSH..."
          sleep 60

      - name: Configure SSH on instances
        run: |
          cd $GITHUB_WORKSPACE/infra/ansible
          # Extraire les adresses IP
          GITHUB_RUNNER_IP=$(jq -r '.github_runner_ip.value' terraform-outputs.json)
          SONARQUBE_IP=$(jq -r '.sonarqube_ip.value' terraform-outputs.json)
          MONITORING_IP=$(jq -r '.monitoring_ip.value' terraform-outputs.json)
          
          # Attendre que les instances soient accessibles
          for IP in $GITHUB_RUNNER_IP $SONARQUBE_IP $MONITORING_IP; do
            echo "Waiting for $IP to be accessible..."
            timeout 300 bash -c "until nc -z $IP 22; do sleep 5; done" || echo "Timeout waiting for $IP"
          done
       
      - name: Generate GitHub Runner token
        id: get-runner-token
        continue-on-error: true
        run: |
          # Utiliser le token PAT avec les permissions nécessaires
          TOKEN="${{ secrets.RUNNER_TOKEN }}"
          if [ -z "$TOKEN" ]; then
            echo "::warning::RUNNER_TOKEN secret is not set. Using a placeholder token."
            echo "placeholder-token" > $GITHUB_WORKSPACE/ssh-keys/github_runner_token.txt
          else
            RESPONSE=$(curl -s -X POST \
              -H "Authorization: token $TOKEN" \
              -H "Accept: application/vnd.github.v3+json" \
              https://api.github.com/repos/${{ github.repository }}/actions/runners/registration-token)
            
            RUNNER_TOKEN=$(echo $RESPONSE | jq -r .token)
            if [ "$RUNNER_TOKEN" != "null" ] && [ -n "$RUNNER_TOKEN" ]; then
              echo $RUNNER_TOKEN > $GITHUB_WORKSPACE/ssh-keys/github_runner_token.txt
              echo "token=$RUNNER_TOKEN" >> $GITHUB_OUTPUT
            else
              echo "::warning::Failed to get runner token. Using a placeholder token."
              echo "placeholder-token" > $GITHUB_WORKSPACE/ssh-keys/github_runner_token.txt
              echo "token=placeholder-token" >> $GITHUB_OUTPUT
            fi
          fi
      
      - name: Upload updated credentials
        uses: actions/upload-artifact@v4
        with:
          name: credentials-updated
          path: ${{ github.workspace }}/ssh-keys/
          retention-days: 7
      
      - name: Run Ansible playbook
        continue-on-error: true
        run: |
          cd $GITHUB_WORKSPACE/infra/ansible
          export ANSIBLE_HOST_KEY_CHECKING=False
          ansible-playbook -i inventory.ini playbook.yml \
            -e "github_account=${{ github.repository_owner }} github_repo=${{ github.repository }} runner_token=${{ steps.get-runner-token.outputs.token }}" \
            --ssh-common-args='-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=10' \
            -vvv
            
  generate-report:
    needs: configure-servers
    runs-on: ubuntu-latest
    steps:
      - name: Download Terraform Outputs
        uses: actions/download-artifact@v4
        with:
          name: terraform-outputs
      
      - name: Download credentials
        uses: actions/download-artifact@v4
        with:
          name: credentials-updated
          path: ./credentials
      
      - name: Generate deployment report
        run: |
          cat > deployment-report.md << EOF
          # Rapport de déploiement
          
          ## Informations d'infrastructure
          
          - **GitHub Runner IP**: $(jq -r '.github_runner_ip.value' terraform-outputs.json)
          - **SonarQube IP**: $(jq -r '.sonarqube_ip.value' terraform-outputs.json)
          - **Monitoring IP**: $(jq -r '.monitoring_ip.value' terraform-outputs.json)
          - **Base de données**: $(jq -r '.db_endpoint.value' terraform-outputs.json)
          - **Cluster EKS**: $(jq -r '.eks_cluster_name.value' terraform-outputs.json)
          
          ## Accès
          
          Les informations d'accès ont été sauvegardées dans les artifacts de cette exécution:
          
          - Clé SSH privée
          - Mot de passe de la base de données
          - Token GitHub Runner
          
          ## Environnement déployé
          
          $(if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then echo "${{ github.event.inputs.environment }}"; elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then echo "production"; elif [[ "${{ github.ref }}" == "refs/heads/staging" ]]; then echo "staging"; elif [[ "${{ github.ref }}" == "refs/heads/development" ]]; then echo "development"; else echo "development"; fi)
          
          ## Date de déploiement
          
          $(date)
          EOF
      
      - name: Upload deployment report
        uses: actions/upload-artifact@v4
        with:
          name: deployment-report
          path: ./deployment-report.md
          retention-days: 30