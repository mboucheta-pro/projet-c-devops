name: CI/CD Pipeline

on:
  push:
    branches: [ main, development, staging ]
  pull_request:
    branches: [ main, development, staging ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environnement à déployer'
        required: true
        default: 'development'
        type: choice
        options:
          - development
          - staging
          - production
      confirm_production:
        description: 'Tapez "CONFIRMER" pour déployer en production'
        required: false
        type: string

env:
  AWS_REGION: ca-central-1
  ECR_REPOSITORY_FRONTEND: projet-c/frontend
  ECR_REPOSITORY_BACKEND: projet-c/backend
  EKS_CLUSTER_NAME: projet-c-cluster
  TF_VAR_region: ca-central-1
  TF_BACKEND_BUCKET: projet-c-terraform-state
  TF_BACKEND_DYNAMODB: projet-c-terraform-locks

jobs:
  build-and-test:
    needs: configure-servers
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          
      - name: Install backend dependencies
        run: |
          cd backend
          npm install
      
      - name: Run backend tests
        run: |
          cd backend
          npm test || echo "No tests specified"
      
      - name: Build and test frontend
        run: |
          cd frontend
          echo "Frontend tests would run here"
  
  security-scan:
    needs: build-and-test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Run Trivy vulnerability scanner for backend
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: './backend'
          format: 'table'
          exit-code: '1'
          ignore-unfixed: true
          severity: 'CRITICAL,HIGH'
      
      - name: Run Trivy vulnerability scanner for frontend
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: './frontend'
          format: 'table'
          exit-code: '1'
          ignore-unfixed: true
          severity: 'CRITICAL,HIGH'
  
  build-and-push:
    needs: security-scan
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Decode AWS credentials
        run: |
          echo "${{ secrets.AWS_CREDENTIALS_BASE64 }}" | base64 -d > aws-credentials.json
          echo "AWS_ACCESS_KEY_ID=$(jq -r .aws_access_key_id aws-credentials.json)" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=$(jq -r .aws_secret_access_key aws-credentials.json)" >> $GITHUB_ENV
          rm aws-credentials.json
      
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1
      
      - name: Set environment and tags
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "ENV=${{ github.event.inputs.environment }}" >> $GITHUB_ENV
            echo "TAG=${{ github.event.inputs.environment }}-${{ github.sha }}" >> $GITHUB_ENV
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "ENV=production" >> $GITHUB_ENV
            echo "TAG=prod-${{ github.sha }}" >> $GITHUB_ENV
          elif [[ "${{ github.ref }}" == "refs/heads/staging" ]]; then
            echo "ENV=staging" >> $GITHUB_ENV
            echo "TAG=staging-${{ github.sha }}" >> $GITHUB_ENV
          elif [[ "${{ github.ref }}" == "refs/heads/development" ]]; then
            echo "ENV=development" >> $GITHUB_ENV
            echo "TAG=dev-${{ github.sha }}" >> $GITHUB_ENV
          else
            echo "ENV=development" >> $GITHUB_ENV
            echo "TAG=dev-${{ github.sha }}" >> $GITHUB_ENV
          fi
      
      - name: Create ECR repositories if they don't exist
        run: |
          aws ecr describe-repositories --repository-names $ECR_REPOSITORY_FRONTEND || aws ecr create-repository --repository-name $ECR_REPOSITORY_FRONTEND
          aws ecr describe-repositories --repository-names $ECR_REPOSITORY_BACKEND || aws ecr create-repository --repository-name $ECR_REPOSITORY_BACKEND
      
      - name: Build, tag, and push frontend image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          cd frontend
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:${{ env.TAG }} .
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:${{ env.TAG }} $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:${{ env.ENV }}-latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:${{ env.TAG }}
          docker push $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:${{ env.ENV }}-latest
      
      - name: Build, tag, and push backend image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          cd backend
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:${{ env.TAG }} .
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:${{ env.TAG }} $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:${{ env.ENV }}-latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:${{ env.TAG }}
          docker push $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:${{ env.ENV }}-latest
  
  deploy:
    needs: [build-and-push]
    runs-on: ubuntu-latest
    if: ${{ github.event_name != 'workflow_dispatch' || github.event.inputs.environment != 'production' || github.event.inputs.confirm_production == 'CONFIRMER' }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Decode AWS credentials
        run: |
          echo "${{ secrets.AWS_CREDENTIALS_BASE64 }}" | base64 -d > aws-credentials.json
          echo "AWS_ACCESS_KEY_ID=$(jq -r .aws_access_key_id aws-credentials.json)" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=$(jq -r .aws_secret_access_key aws-credentials.json)" >> $GITHUB_ENV
          rm aws-credentials.json
      
      - name: Download Terraform Outputs
        uses: actions/download-artifact@v4
        with:
          name: terraform-outputs
      
      - name: Download credentials
        uses: actions/download-artifact@v4
        with:
          name: credentials
          path: ./credentials
      
      - name: Set environment
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "ENV=${{ github.event.inputs.environment }}" >> $GITHUB_ENV
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "ENV=production" >> $GITHUB_ENV
          elif [[ "${{ github.ref }}" == "refs/heads/staging" ]]; then
            echo "ENV=staging" >> $GITHUB_ENV
          elif [[ "${{ github.ref }}" == "refs/heads/development" ]]; then
            echo "ENV=development" >> $GITHUB_ENV
          else
            echo "ENV=development" >> $GITHUB_ENV
          fi
          
          echo "EKS_CLUSTER_NAME=$(jq -r '.eks_cluster_name.value' terraform-outputs.json)" >> $GITHUB_ENV
      
      - name: Update kube config
        run: aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}
      
      - name: Get ECR account URL
        id: get-ecr-url
        run: |
          ECR_ACCOUNT_URL=$(aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY_FRONTEND }} --query 'repositories[0].repositoryUri' --output text | sed 's|/.*||')
          echo "ECR_ACCOUNT_URL=$ECR_ACCOUNT_URL" >> $GITHUB_ENV
      
      - name: Initialize database
        continue-on-error: true
        run: |
          echo "Skipping database initialization for now"
      
      - name: Deploy to EKS
        run: |
          # Créer le namespace s'il n'existe pas
          kubectl apply -f kubernetes/environments/namespaces.yaml
          
          # Remplacer les variables dans les fichiers YAML
          find kubernetes/ -type f -name "*.yaml" -exec sed -i "s|\${AWS_ACCOUNT_ID}|${{ env.ECR_ACCOUNT_URL }}|g" {} \;
          
          # Appliquer les configurations spécifiques à l'environnement
          kubectl apply -f kubernetes/environments/${{ env.ENV }}/backend-config.yaml
          
          # Appliquer les configurations communes
          kubectl apply -f kubernetes/configmap.yaml -n ${{ env.ENV }}
          
          # Modifier le namespace dans les fichiers de déploiement
          sed -i "s|namespace: .*|namespace: ${{ env.ENV }}|g" kubernetes/backend-deployment.yaml
          sed -i "s|namespace: .*|namespace: ${{ env.ENV }}|g" kubernetes/frontend-deployment.yaml
          sed -i "s|namespace: .*|namespace: ${{ env.ENV }}|g" kubernetes/ingress.yaml
          
          # Appliquer les déploiements
          kubectl apply -f kubernetes/backend-deployment.yaml
          kubectl apply -f kubernetes/frontend-deployment.yaml
          kubectl apply -f kubernetes/ingress.yaml
          
          # Vérifier le déploiement
          kubectl get pods -n ${{ env.ENV }}
