name: CI/CD Pipeline

on:
  push:
    branches: [ main, development, staging ]
  pull_request:
    branches: [ main, development, staging ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environnement à déployer'
        required: true
        default: 'development'
        type: choice
        options:
          - development
          - staging
          - production
      confirm_production:
        description: 'Tapez "CONFIRMER" pour déployer en production'
        required: false
        type: string

env:
  AWS_REGION: ca-central-1
  ECR_REPOSITORY_FRONTEND: projet-c/frontend
  ECR_REPOSITORY_BACKEND: projet-c/backend
  EKS_CLUSTER_NAME: projet-c-cluster
  TF_VAR_region: ca-central-1
  TF_BACKEND_BUCKET: projet-c-terraform-state
  TF_BACKEND_DYNAMODB: projet-c-terraform-locks

jobs:
  setup-backend:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Decode AWS credentials
        run: |
          echo "${{ secrets.AWS_CREDENTIALS_BASE64 }}" | base64 -d > aws-credentials.json
          echo "AWS_ACCESS_KEY_ID=$(jq -r .aws_access_key_id aws-credentials.json)" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=$(jq -r .aws_secret_access_key aws-credentials.json)" >> $GITHUB_ENV
          rm aws-credentials.json
      
      - name: Configure AWS CLI
        run: |
          aws configure set region ${{ env.AWS_REGION }}
          aws configure set output json
      
      - name: Create S3 bucket if not exists
        run: |
          if ! aws s3api head-bucket --bucket ${{ env.TF_BACKEND_BUCKET }} 2>/dev/null; then
            aws s3api create-bucket \
              --bucket ${{ env.TF_BACKEND_BUCKET }} \
              --region ${{ env.AWS_REGION }} \
              --create-bucket-configuration LocationConstraint=${{ env.AWS_REGION }}
            
            # Activer le versionnement
            aws s3api put-bucket-versioning \
              --bucket ${{ env.TF_BACKEND_BUCKET }} \
              --versioning-configuration Status=Enabled
            
            # Activer le chiffrement
            aws s3api put-bucket-encryption \
              --bucket ${{ env.TF_BACKEND_BUCKET }} \
              --server-side-encryption-configuration '{
                "Rules": [
                  {
                    "ApplyServerSideEncryptionByDefault": {
                      "SSEAlgorithm": "AES256"
                    }
                  }
                ]
              }'
            
            # Bloquer l'accès public
            aws s3api put-public-access-block \
              --bucket ${{ env.TF_BACKEND_BUCKET }} \
              --public-access-block-configuration "BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true"
          else
            echo "S3 bucket ${{ env.TF_BACKEND_BUCKET }} already exists"
          fi
      
      - name: Create DynamoDB table if not exists
        run: |
          if ! aws dynamodb describe-table --table-name ${{ env.TF_BACKEND_DYNAMODB }} 2>/dev/null; then
            aws dynamodb create-table \
              --region ${{ env.AWS_REGION }} \
              --table-name ${{ env.TF_BACKEND_DYNAMODB }} \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST
          else
            echo "DynamoDB table ${{ env.TF_BACKEND_DYNAMODB }} already exists"
          fi
  
  infrastructure:
    needs: setup-backend
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Decode AWS credentials
        run: |
          echo "${{ secrets.AWS_CREDENTIALS_BASE64 }}" | base64 -d > aws-credentials.json
          echo "AWS_ACCESS_KEY_ID=$(jq -r .aws_access_key_id aws-credentials.json)" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=$(jq -r .aws_secret_access_key aws-credentials.json)" >> $GITHUB_ENV
          rm aws-credentials.json
      
      - name: Generate SSH key pair
        run: |
          ssh-keygen -t rsa -b 4096 -f id_rsa -N ""
          echo "TF_VAR_ssh_public_key=$(cat id_rsa.pub)" >> $GITHUB_ENV
          mkdir -p ssh-keys
          cp id_rsa ssh-keys/
          cp id_rsa.pub ssh-keys/
      
      - name: Generate DB password
        run: |
          DB_PASSWORD=$(openssl rand -base64 16)
          echo "TF_VAR_db_password=$DB_PASSWORD" >> $GITHUB_ENV
          echo "$DB_PASSWORD" > ssh-keys/db_password.txt
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.0.0
      
      - name: Determine environment
        id: determine-env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "ENV=${{ github.event.inputs.environment }}" >> $GITHUB_ENV
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "ENV=production" >> $GITHUB_ENV
          elif [[ "${{ github.ref }}" == "refs/heads/staging" ]]; then
            echo "ENV=staging" >> $GITHUB_ENV
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            echo "ENV=development" >> $GITHUB_ENV
          else
            echo "ENV=development" >> $GITHUB_ENV
          fi
      
      - name: Terraform Init
        working-directory: ./infra/terraform
        run: |
          # Remplacer le placeholder env/ par l'environnement réel dans la clé du backend
          sed -i "s|key            = \"env/|key            = \"${{ env.ENV }}/|g" backend.tf
          terraform init
      
      - name: Terraform Validate
        working-directory: ./infra/terraform
        run: terraform validate
        
      # Aucune étape de gestion d'état n'est nécessaire ici
      
      - name: Determine environment
        id: determine-env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "ENV=${{ github.event.inputs.environment }}" >> $GITHUB_ENV
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "ENV=production" >> $GITHUB_ENV
          elif [[ "${{ github.ref }}" == "refs/heads/staging" ]]; then
            echo "ENV=staging" >> $GITHUB_ENV
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            echo "ENV=development" >> $GITHUB_ENV
          else
            echo "ENV=development" >> $GITHUB_ENV
          fi
      
      - name: Terraform Plan
        working-directory: ./infra/terraform
        run: terraform plan -var="environment=${{ env.ENV }}" -out=tfplan
      
      - name: Terraform Apply
        working-directory: ./infra/terraform
        run: terraform apply -auto-approve tfplan
      
      - name: Save Terraform Outputs
        working-directory: ./infra/terraform
        run: |
          terraform output -json > terraform-outputs.json
          echo "GITHUB_RUNNER_IP=$(terraform output -raw github_runner_ip)" >> $GITHUB_ENV
          echo "SONARQUBE_IP=$(terraform output -raw sonarqube_ip)" >> $GITHUB_ENV
          echo "MONITORING_IP=$(terraform output -raw monitoring_ip)" >> $GITHUB_ENV
          echo "DB_ENDPOINT=$(terraform output -raw db_endpoint)" >> $GITHUB_ENV
          echo "EKS_CLUSTER_ENDPOINT=$(terraform output -raw eks_cluster_endpoint)" >> $GITHUB_ENV
          echo "EKS_CLUSTER_NAME=$(terraform output -raw eks_cluster_name)" >> $GITHUB_ENV
      
      - name: Upload Terraform Outputs
        uses: actions/upload-artifact@v4
        with:
          name: terraform-outputs
          path: ./infra/terraform/terraform-outputs.json
          retention-days: 7
      
      - name: Upload SSH keys and DB password
        uses: actions/upload-artifact@v4
        with:
          name: credentials
          path: ./ssh-keys/
          retention-days: 7
  
  configure-servers:
    needs: infrastructure
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Decode AWS credentials
        run: |
          echo "${{ secrets.AWS_CREDENTIALS_BASE64 }}" | base64 -d > aws-credentials.json
          echo "AWS_ACCESS_KEY_ID=$(jq -r .aws_access_key_id aws-credentials.json)" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=$(jq -r .aws_secret_access_key aws-credentials.json)" >> $GITHUB_ENV
          rm aws-credentials.json
      
      - name: Download Terraform Outputs
        uses: actions/download-artifact@v4
        with:
          name: terraform-outputs
          path: ./infra/ansible
      
      - name: Download SSH keys
        uses: actions/download-artifact@v4
        with:
          name: credentials
          path: ./ssh-keys
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
      
      - name: Install Ansible
        run: |
          python -m pip install --upgrade pip
          pip install ansible boto3
      
      - name: Create Ansible inventory
        working-directory: ./infra/ansible
        run: |
          cat > inventory.ini << EOF
          [github_runner]
          $(jq -r '.github_runner_ip.value' terraform-outputs.json) ansible_user=ec2-user ansible_ssh_private_key_file=~/.ssh/id_rsa
          
          [sonarqube]
          $(jq -r '.sonarqube_ip.value' terraform-outputs.json) ansible_user=ec2-user ansible_ssh_private_key_file=~/.ssh/id_rsa
          
          [monitoring]
          $(jq -r '.monitoring_ip.value' terraform-outputs.json) ansible_user=ec2-user ansible_ssh_private_key_file=~/.ssh/id_rsa
          EOF
      
      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          cp ./ssh-keys/id_rsa ~/.ssh/
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H $(jq -r '.github_runner_ip.value' ./infra/ansible/terraform-outputs.json) >> ~/.ssh/known_hosts
          ssh-keyscan -H $(jq -r '.sonarqube_ip.value' ./infra/ansible/terraform-outputs.json) >> ~/.ssh/known_hosts
          ssh-keyscan -H $(jq -r '.monitoring_ip.value' ./infra/ansible/terraform-outputs.json) >> ~/.ssh/known_hosts
      
      - name: Generate GitHub Runner token
        id: get-runner-token
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const response = await github.rest.actions.createRegistrationTokenForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo
            });
            return response.data.token;
      
      - name: Save GitHub Runner token
        run: |
          echo "${{ steps.get-runner-token.outputs.result }}" > ./ssh-keys/github_runner_token.txt
      
      - name: Upload updated credentials
        uses: actions/upload-artifact@v4
        with:
          name: credentials-updated
          path: ./ssh-keys/
          retention-days: 7
      
      - name: Run Ansible playbook
        working-directory: ./infra/ansible
        run: |
          ansible-playbook -i inventory.ini playbook.yml -e "github_account=${{ github.repository_owner }} github_repo=${{ github.repository }} runner_token=${{ steps.get-runner-token.outputs.result }}"
  
  build-and-test:
    needs: configure-servers
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          
      - name: Install backend dependencies
        run: |
          cd backend
          npm ci
      
      - name: Run backend tests
        run: |
          cd backend
          npm test || echo "No tests specified"
      
      - name: Build and test frontend
        run: |
          cd frontend
          echo "Frontend tests would run here"
  
  security-scan:
    needs: build-and-test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Run Trivy vulnerability scanner for backend
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: './backend'
          format: 'table'
          exit-code: '1'
          ignore-unfixed: true
          severity: 'CRITICAL,HIGH'
      
      - name: Run Trivy vulnerability scanner for frontend
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: './frontend'
          format: 'table'
          exit-code: '1'
          ignore-unfixed: true
          severity: 'CRITICAL,HIGH'
  
  build-and-push:
    needs: security-scan
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Decode AWS credentials
        run: |
          echo "${{ secrets.AWS_CREDENTIALS_BASE64 }}" | base64 -d > aws-credentials.json
          echo "AWS_ACCESS_KEY_ID=$(jq -r .aws_access_key_id aws-credentials.json)" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=$(jq -r .aws_secret_access_key aws-credentials.json)" >> $GITHUB_ENV
          rm aws-credentials.json
      
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1
      
      - name: Determine environment
        id: determine-env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "ENV=${{ github.event.inputs.environment }}" >> $GITHUB_ENV
            echo "TAG=${{ github.event.inputs.environment }}-${{ github.sha }}" >> $GITHUB_ENV
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "ENV=production" >> $GITHUB_ENV
            echo "TAG=prod-${{ github.sha }}" >> $GITHUB_ENV
          elif [[ "${{ github.ref }}" == "refs/heads/staging" ]]; then
            echo "ENV=staging" >> $GITHUB_ENV
            echo "TAG=staging-${{ github.sha }}" >> $GITHUB_ENV
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            echo "ENV=development" >> $GITHUB_ENV
            echo "TAG=dev-${{ github.sha }}" >> $GITHUB_ENV
          else
            echo "ENV=development" >> $GITHUB_ENV
            echo "TAG=dev-${{ github.sha }}" >> $GITHUB_ENV
          fi
      
      - name: Create ECR repositories if they don't exist
        run: |
          aws ecr describe-repositories --repository-names $ECR_REPOSITORY_FRONTEND || aws ecr create-repository --repository-name $ECR_REPOSITORY_FRONTEND
          aws ecr describe-repositories --repository-names $ECR_REPOSITORY_BACKEND || aws ecr create-repository --repository-name $ECR_REPOSITORY_BACKEND
      
      - name: Build, tag, and push frontend image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          cd frontend
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:${{ env.TAG }} .
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:${{ env.TAG }} $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:${{ env.ENV }}-latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:${{ env.TAG }}
          docker push $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:${{ env.ENV }}-latest
      
      - name: Build, tag, and push backend image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          cd backend
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:${{ env.TAG }} .
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:${{ env.TAG }} $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:${{ env.ENV }}-latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:${{ env.TAG }}
          docker push $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:${{ env.ENV }}-latest
  
  deploy:
    needs: [build-and-push, configure-servers]
    runs-on: ubuntu-latest
    if: ${{ github.event_name != 'workflow_dispatch' || github.event.inputs.environment != 'production' || github.event.inputs.confirm_production == 'CONFIRMER' }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Decode AWS credentials
        run: |
          echo "${{ secrets.AWS_CREDENTIALS_BASE64 }}" | base64 -d > aws-credentials.json
          echo "AWS_ACCESS_KEY_ID=$(jq -r .aws_access_key_id aws-credentials.json)" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=$(jq -r .aws_secret_access_key aws-credentials.json)" >> $GITHUB_ENV
          rm aws-credentials.json
      
      - name: Download Terraform Outputs
        uses: actions/download-artifact@v4
        with:
          name: terraform-outputs
      
      - name: Download credentials
        uses: actions/download-artifact@v4
        with:
          name: credentials
          path: ./credentials
      
      - name: Set EKS cluster name
        run: echo "EKS_CLUSTER_NAME=$(jq -r '.eks_cluster_name.value' terraform-outputs.json)" >> $GITHUB_ENV
      
      - name: Update kube config
        run: aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}
      
      - name: Determine environment
        id: determine-env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "ENV=${{ github.event.inputs.environment }}" >> $GITHUB_ENV
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "ENV=production" >> $GITHUB_ENV
          elif [[ "${{ github.ref }}" == "refs/heads/staging" ]]; then
            echo "ENV=staging" >> $GITHUB_ENV
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            echo "ENV=development" >> $GITHUB_ENV
          else
            echo "ENV=development" >> $GITHUB_ENV
          fi
      
      - name: Get ECR account URL
        id: get-ecr-url
        run: |
          ECR_ACCOUNT_URL=$(aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY_FRONTEND }} --query 'repositories[0].repositoryUri' --output text | sed 's|/.*||')
          echo "ECR_ACCOUNT_URL=$ECR_ACCOUNT_URL" >> $GITHUB_ENV
      
      - name: Initialize database
        run: |
          DB_ENDPOINT=$(jq -r '.db_endpoint.value' terraform-outputs.json)
          DB_PASSWORD=$(cat ./credentials/db_password.txt)
          mysql -h ${DB_ENDPOINT%:*} -u dbadmin -p$DB_PASSWORD < database/init.sql
      
      - name: Deploy to EKS
        run: |
          # Créer le namespace s'il n'existe pas
          kubectl apply -f kubernetes/environments/namespaces.yaml
          
          # Remplacer les variables dans les fichiers YAML
          find kubernetes/ -type f -name "*.yaml" -exec sed -i "s|\${AWS_ACCOUNT_ID}|${{ env.ECR_ACCOUNT_URL }}|g" {} \;
          
          # Appliquer les configurations spécifiques à l'environnement
          kubectl apply -f kubernetes/environments/${{ env.ENV }}/backend-config.yaml
          
          # Appliquer les configurations communes
          kubectl apply -f kubernetes/configmap.yaml -n ${{ env.ENV }}
          
          # Modifier le namespace dans les fichiers de déploiement
          sed -i "s|namespace: .*|namespace: ${{ env.ENV }}|g" kubernetes/backend-deployment.yaml
          sed -i "s|namespace: .*|namespace: ${{ env.ENV }}|g" kubernetes/frontend-deployment.yaml
          sed -i "s|namespace: .*|namespace: ${{ env.ENV }}|g" kubernetes/ingress.yaml
          
          # Appliquer les déploiements
          kubectl apply -f kubernetes/backend-deployment.yaml
          kubectl apply -f kubernetes/frontend-deployment.yaml
          kubectl apply -f kubernetes/ingress.yaml
          
          # Vérifier le déploiement
          kubectl get pods -n ${{ env.ENV }}
  
  generate-report:
    needs: deploy
    runs-on: ubuntu-latest
    steps:
      - name: Download Terraform Outputs
        uses: actions/download-artifact@v4
        with:
          name: terraform-outputs
      
      - name: Download credentials
        uses: actions/download-artifact@v4
        with:
          name: credentials-updated
          path: ./credentials
      
      - name: Generate deployment report
        run: |
          cat > deployment-report.md << EOF
          # Rapport de déploiement
          
          ## Informations d'infrastructure
          
          - **GitHub Runner IP**: $(jq -r '.github_runner_ip.value' terraform-outputs.json)
          - **SonarQube IP**: $(jq -r '.sonarqube_ip.value' terraform-outputs.json)
          - **Monitoring IP**: $(jq -r '.monitoring_ip.value' terraform-outputs.json)
          - **Base de données**: $(jq -r '.db_endpoint.value' terraform-outputs.json)
          - **Cluster EKS**: $(jq -r '.eks_cluster_name.value' terraform-outputs.json)
          
          ## Accès
          
          Les informations d'accès ont été sauvegardées dans les artifacts de cette exécution:
          
          - Clé SSH privée
          - Mot de passe de la base de données
          - Token GitHub Runner
          
          ## Environnement déployé
          
          $(if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then echo "${{ github.event.inputs.environment }}"; elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then echo "production"; elif [[ "${{ github.ref }}" == "refs/heads/staging" ]]; then echo "staging"; elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then echo "development"; else echo "development"; fi)
          
          ## Date de déploiement
          
          $(date)
          EOF
      
      - name: Upload deployment report
        uses: actions/upload-artifact@v4
        with:
          name: deployment-report
          path: ./deployment-report.md
          retention-days: 30